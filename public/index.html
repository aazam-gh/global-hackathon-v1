<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Graph Learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; font: 16px system-ui, -apple-system, Segoe UI, Roboto; }
    #toolbar { padding: 8px 12px; border-bottom: 1px solid #eee; display:flex; gap:8px; align-items:center; }
    #cy { width: 100vw; height: calc(100vh - 56px); }
    .pill { padding:4px 8px; border:1px solid #ddd; border-radius:999px; }
    #status { color:#666; font-size:13px; margin-left:auto; }
    .pill:disabled { opacity:0.6; pointer-events:none; }
    .hidden { display:none; }
    .suggest-panel {
      position: fixed;
      top: 64px;
      right: 12px;
      width: 360px;
      max-width: calc(100vw - 24px);
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      padding: 12px;
      z-index: 10;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
    }
    /* Ensure quiz panel is above chat and suggestion panels */
    #quizPanel { z-index: 20; }
    .suggest-panel.hidden { display: none; }
    .suggest-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; cursor: move; }
    .suggest-panel .actions { display:flex; gap:6px; }
    .suggest-body { white-space:pre-wrap; line-height:1.4; font-size:14px; color:#2c3e50; overflow:auto; max-height: 55vh; -webkit-overflow-scrolling: touch; }
    .suggest-panel .hint { margin-top:8px; font-size:12px; color:#888; }

    /* Chat / node detail panel */
    .chat-panel {
      position: fixed;
      top: 64px;
      right: 12px;
      width: 420px;
      max-width: calc(100vw - 24px);
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      padding: 12px;
      z-index: 11;
      max-height: 78vh;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .chat-panel.hidden { display:none; }
    .chat-header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .chat-title { font-weight:600; font-size:15px; }
    .meta { font-size:12px; color:#666; display:flex; gap:6px; flex-wrap:wrap; }
    .section { border-top: 1px solid #f0f0f0; padding-top:8px; }
    .resources a { display:block; font-size:13px; margin:2px 0; color:#2c3e50; text-decoration: none; }
    .resources a:hover { text-decoration: underline; }
    .chat-messages { flex:1; overflow:auto; -webkit-overflow-scrolling: touch; background:#fafafa; border:1px solid #f0f0f0; border-radius:8px; padding:8px; }
    .msg { margin:6px 0; }
    .msg.user { color:#34495e; }
    .msg.assistant { color:#2c3e50; }
    .msg .role { font-weight:600; margin-right:6px; }
    .chat-input { display:flex; gap:6px; align-items:flex-end; }
    .chat-input textarea { flex:1; min-height:44px; max-height:120px; resize:vertical; padding:6px 8px; border:1px solid #ddd; border-radius:8px; font: inherit; }
    .row { display:flex; align-items:center; gap:6px; }
    .tag { background:#eef2f7; color:#2c3e50; font-size:12px; padding:2px 6px; border-radius:999px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="q" placeholder="Search concept…" class="pill"/>
    <button id="focus" class="pill">Focus</button>
    <button id="reset" class="pill">Reset</button>
    <button id="suggest" class="pill" title="Ask AI what to learn next (shortcut: N)">What's next?</button>
    <span id="progress" class="pill" title="Overall progress"></span>
    <span id="status"></span>
  </div>
  <div id="suggestPanel" class="suggest-panel hidden" role="region" aria-label="Suggestion panel">
    <div class="suggest-header">
      <span><strong>Suggested next step</strong></span>
      <div class="actions">
        <button id="copySuggest" class="pill" title="Copy suggestion">Copy</button>
        <button id="closeSuggest" class="pill" title="Close panel" aria-label="Close suggestion panel">Close</button>
      </div>
    </div>
    <div id="suggestText" class="suggest-body"></div>
    <div class="hint">Press N to ask again</div>
  </div>
  <div id="chatPanel" class="chat-panel hidden" role="region" aria-label="Node chat panel">
    <div class="chat-header">
      <div>
        <div id="chatTitle" class="chat-title">Topic</div>
        <div id="chatMeta" class="meta"></div>
        <div id="chatProgress" class="meta"></div>
      </div>
      <div class="row">
        <button id="toggleKnown" class="pill" title="Mark as known">Mark known</button>
        <button id="openQuiz" class="pill" title="Quiz this topic">Quiz</button>
        <button id="closeChat" class="pill" aria-label="Close">Close</button>
      </div>
    </div>
    <div id="chatSummary" class="section" style="font-size:14px; color:#2c3e50;"></div>
    <div class="row" style="flex-wrap:wrap; gap:4px">
      <div id="chatKeywords"></div>
    </div>
    <div class="resources section hidden" id="chatResources"></div>
    <!-- No user context size option by design -->
    <div id="chatMessages" class="chat-messages" aria-live="polite"></div>
    <form id="chatForm" class="chat-input">
      <textarea id="chatQuestion" placeholder="Ask about this topic… (Shift+Enter for newline)"></textarea>
      <button id="sendChat" class="pill" type="submit">Ask</button>
    </form>
  </div>
  <div id="cy"></div>

  <!-- Quiz panel -->
  <div id="quizPanel" class="suggest-panel hidden" role="dialog" aria-label="Quiz panel">
    <div class="suggest-header">
      <span><strong>Quiz</strong></span>
      <div class="actions">
        <button id="regenQuiz" class="pill" title="Regenerate">Regenerate</button>
        <button id="closeQuiz" class="pill" title="Close">Close</button>
      </div>
    </div>
    <div id="quizBody" class="suggest-body"></div>
    <div class="hint">Answers are saved locally</div>
  </div>

  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    const container = document.getElementById('cy');
    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);

    function edgeColor(type) {
      if (type === 'prereq') return '#2c3e50';
      if (type === 'refines') return '#8e44ad';
      if (type === 'applies-to') return '#27ae60';
      return '#bbb';
    }

    const slowPhysics = {
      enabled: true,
      solver: 'barnesHut',
      stabilization: false,
      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.0005,
        springLength: 200,
        springConstant: 0.015,
        damping: 0.85,
        avoidOverlap: 0
      },
      maxVelocity: 0.8,
      minVelocity: 0.0001,
      timestep: 0.4,
      adaptiveTimestep: true
    };

    const fastPhysics = {
      enabled: true,
      solver: 'barnesHut',
      stabilization: false,
      barnesHut: {
        gravitationalConstant: -15000,
        centralGravity: 0.005,
        springLength: 160,
        springConstant: 0.03,
        damping: 0.5,
        avoidOverlap: 0
      },
      maxVelocity: 5,
      minVelocity: 0.2,
      timestep: 0.8,
      adaptiveTimestep: true
    };

    const options = {
      interaction: { hover: true, multiselect: true, selectConnectedEdges: true },
      physics: fastPhysics,
      nodes: { shape: 'dot', size: 14, font: { size: 12 }, borderWidth: 1 },
      edges: {
        width: 1,
        arrows: { to: { enabled: true, scaleFactor: 0.6 } },
        smooth: { type: 'dynamic' },
        color: { color: '#bbb', highlight: '#f39c12' }
      },
      groups: {
        concept: { color: { background: '#3498db', border: '#2980b9' } },
        skill: { color: { background: '#1abc9c', border: '#16a085' } },
        example: { color: { background: '#95a5a6', border: '#7f8c8d' } },
        theorem: { color: { background: '#e67e22', border: '#d35400' } }
      }
    };

    const network = new vis.Network(container, { nodes, edges }, options);

    let graph;
    fetch('/graph').then(r => r.json()).then(g => {
      graph = g;
      nodes.add(g.nodes.map(n => ({ id: n.id, label: n.title, title: n.summary || '', group: n.kind })));
      edges.add(g.edges.map(e => ({
        id: `${e.source}->${e.target}:${e.type}`,
        from: e.source,
        to: e.target,
        arrows: 'to',
        dashes: e.type === 'refines' ? [5, 5] : (e.type === 'applies-to' ? [10, 5] : false),
        color: { color: edgeColor(e.type) }
      })));
      network.fit({ animation: { duration: 500, easing: 'easeInOutQuad' } });
      setTimeout(() => {
        network.setOptions({ physics: slowPhysics });
      }, 1500);

      // Render known ids on load
      renderKnown();
      updateOverallProgress();

      network.on('click', (params) => {
        if (params.nodes && params.nodes.length) {
          const id = params.nodes[0];
          openChatForNode(id);
        }
      });
    });

    const $q = document.getElementById('q');
    const $status = document.getElementById('status');
    const $suggestBtn = document.getElementById('suggest');
    const $panel = document.getElementById('suggestPanel');
    const $suggestText = document.getElementById('suggestText');
    const $copySuggest = document.getElementById('copySuggest');
    const $closeSuggest = document.getElementById('closeSuggest');
    const $header = $panel.querySelector('.suggest-header');

    // Chat panel els
    const $chatPanel = document.getElementById('chatPanel');
    const $chatTitle = document.getElementById('chatTitle');
    const $chatMeta = document.getElementById('chatMeta');
    const $chatSummary = document.getElementById('chatSummary');
    const $chatKeywords = document.getElementById('chatKeywords');
    const $chatResources = document.getElementById('chatResources');
    const $chatMessages = document.getElementById('chatMessages');
    const $chatForm = document.getElementById('chatForm');
    const $chatQuestion = document.getElementById('chatQuestion');
    // radius removed from UI; server uses fixed small context
    const $toggleKnown = document.getElementById('toggleKnown');
    const $openQuiz = document.getElementById('openQuiz');
    const $closeChat = document.getElementById('closeChat');
    const $quizPanel = document.getElementById('quizPanel');
    const $quizBody = document.getElementById('quizBody');
    const $closeQuiz = document.getElementById('closeQuiz');
    const $regenQuiz = document.getElementById('regenQuiz');
    let currentNodeId = null;
    const chatHistoryByNode = new Map();
    const knownKey = 'knownIds';
    // Reset known progress on each page load/refresh
    try { localStorage.removeItem(knownKey); } catch {}
    function getKnown() {
      try { return new Set(JSON.parse(localStorage.getItem(knownKey) || '[]')); } catch { return new Set(); }
    }
    function saveKnown(set) {
      localStorage.setItem(knownKey, JSON.stringify(Array.from(set)));
    }
    function renderKnown() {
      const set = getKnown();
      nodes.update(nodes.get().map(n => set.has(n.id)
        ? { id: n.id, borderWidth: 3, color: { border: '#27ae60' } }
        : { id: n.id, borderWidth: 1 }));
      updateOverallProgress();
    }

    function updateOverallProgress() {
      try {
        const total = (graph && Array.isArray(graph.nodes)) ? graph.nodes.length : 0;
        const known = getKnown();
        const count = known.size;
        const pct = total > 0 ? Math.round((count / total) * 100) : 0;
        const el = document.getElementById('progress');
        if (el) {
          el.textContent = `Known: ${count}/${total} (${pct}%)`;
        }
      } catch {}
    }

    function showSuggestion(text) {
      $suggestText.textContent = text;
      $panel.classList.remove('hidden');
    }
    function hideSuggestion() {
      $panel.classList.add('hidden');
    }
    $closeSuggest.onclick = hideSuggestion;
    $copySuggest.onclick = async () => {
      try {
        await navigator.clipboard.writeText($suggestText.textContent || '');
        $status.textContent = 'Copied suggestion';
      } catch {}
      setTimeout(() => { $status.textContent = ''; }, 1200);
    };

    // Drag & Drop for suggestion panel (mouse + touch)
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0, startLeft = 0, startTop = 0;
    function onDragStart(e) {
      const target = e.target;
      // Do not start drag when interacting with buttons/controls in header
      if (target && (target.closest('.actions') || target.closest('button, a, input, textarea'))) return;
      const p = e.touches ? e.touches[0] : e;
      isDragging = true;
      const rect = $panel.getBoundingClientRect();
      $panel.style.left = rect.left + 'px';
      $panel.style.top = rect.top + 'px';
      $panel.style.right = 'auto';
      dragStartX = p.clientX;
      dragStartY = p.clientY;
      startLeft = rect.left;
      startTop = rect.top;
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);
      document.addEventListener('touchmove', onDragMove, { passive: false });
      document.addEventListener('touchend', onDragEnd);
      if (e.cancelable) e.preventDefault();
    }
    function onDragMove(e) {
      if (!isDragging) return;
      const p = e.touches ? e.touches[0] : e;
      const dx = p.clientX - dragStartX;
      const dy = p.clientY - dragStartY;
      let newLeft = startLeft + dx;
      let newTop = startTop + dy;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rectNow = $panel.getBoundingClientRect();
      const pw = rectNow.width;
      const ph = rectNow.height;
      newLeft = Math.max(0, Math.min(vw - pw, newLeft));
      newTop = Math.max(0, Math.min(vh - ph, newTop));
      $panel.style.left = newLeft + 'px';
      $panel.style.top = newTop + 'px';
      if (e.cancelable) e.preventDefault();
    }
    function onDragEnd() {
      isDragging = false;
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', onDragEnd);
      document.removeEventListener('touchmove', onDragMove);
      document.removeEventListener('touchend', onDragEnd);
    }
    $header.addEventListener('mousedown', onDragStart);
    $header.addEventListener('touchstart', onDragStart, { passive: false });
    let lastQuery = '';
    let lastQueryIndex = 0;

    $q.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      const term = $q.value.trim().toLowerCase();
      if (!term) return;
      const matches = nodes.getIds({
        filter: it => (it.label || '').toLowerCase().includes(term) || String(it.id).toLowerCase().includes(term)
      });
      if (!matches.length) return;
      if (term === lastQuery) {
        lastQueryIndex = (lastQueryIndex + 1) % matches.length;
      } else {
        lastQuery = term;
        lastQueryIndex = 0;
      }
      const id = matches[lastQueryIndex];
      network.selectNodes([id]);
      network.focus(id, { scale: 1.6, animation: { duration: 600, easing: 'easeInOutQuad' } });
    });
    document.getElementById('focus').onclick = () => {
      const term = $q.value.trim().toLowerCase();
      if (!term) return;
      const matches = nodes.getIds({ filter: it => (it.label || '').toLowerCase().includes(term) || String(it.id).toLowerCase().includes(term) });
      if (matches.length) {
        const id = matches[0];
        const neighborhood = new Set([id, ...network.getConnectedNodes(id)]);
        const allNodes = nodes.getIds();
        const allEdges = edges.getIds();
        nodes.update(allNodes.map(nid => ({ id: nid, hidden: !neighborhood.has(nid) })));
        edges.update(allEdges.map(eid => {
          const e = edges.get(eid);
          const visible = neighborhood.has(e.from) && neighborhood.has(e.to);
          return { id: eid, hidden: !visible };
        }));
        network.fit({ nodes: Array.from(neighborhood), animation: { duration: 500, easing: 'easeInOutQuad' } });
      }
    };

    document.getElementById('reset').onclick = () => {
      nodes.update(nodes.get().map(n => ({ id: n.id, hidden: false })));
      edges.update(edges.get().map(e => ({ id: e.id, hidden: false })));
      network.fit({ animation: { duration: 500, easing: 'easeInOutQuad' } });
    };

    function setSuggestLoading(isLoading) {
      $suggestBtn.disabled = isLoading;
      $suggestBtn.textContent = isLoading ? 'Thinking…' : "What's next?";
      $suggestBtn.setAttribute('aria-busy', String(isLoading));
    }
    async function getSuggestion() {
      try {
        setSuggestLoading(true);
        const selected = network.getSelectedNodes();
        $status.textContent = 'Asking for next step...';
        // Try streaming first
        const body = JSON.stringify({ question: 'What should I learn next?', knownIds: selected });
        let streamed = false;
        try {
          const res = await fetch('/ask/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
          if (!res.ok || !res.body) throw new Error('no stream');
          streamed = true;
          $suggestText.textContent = '';
          $panel.classList.remove('hidden');
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const chunk = buffer.slice(0, idx);
              buffer = buffer.slice(idx + 2);
              const lines = chunk.split('\n');
              let ev = 'message';
              let data = '';
              for (const ln of lines) {
                if (ln.startsWith('event:')) ev = ln.slice(6).trim();
                else if (ln.startsWith('data:')) data += ln.slice(5).trim();
              }
              if (ev === 'token') {
                $suggestText.textContent += data;
              } else if (ev === 'done') {
                try { const obj = JSON.parse(data); if (obj?.answer) $suggestText.textContent = obj.answer; } catch {}
              }
            }
          }
          $status.textContent = 'Suggestion ready.';
        } catch (_) {}
        if (!streamed) {
          // Fallback to non-streaming
          const res = await fetch('/ask', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
          if (!res.ok) throw new Error('Server error ' + res.status);
          const { answer } = await res.json();
          showSuggestion(answer || 'No suggestion returned.');
          $status.textContent = 'Suggestion ready.';
        }
      } catch (err) {
        showSuggestion('There was an error fetching a suggestion. ' + (err && err.message ? err.message : err));
        $status.textContent = 'Failed to get suggestion.';
      } finally {
        setSuggestLoading(false);
        setTimeout(() => { if ($status.textContent) $status.textContent = ''; }, 2000);
      }
    }
    $suggestBtn.onclick = getSuggestion;
    document.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
      if (e.key === 'n' || e.key === 'N') {
        e.preventDefault();
        getSuggestion();
      }
    });

    // Chat panel logic
    function openChatForNode(id) {
      currentNodeId = id;
      $chatMessages.innerHTML = '';
      $chatQuestion.value = '';
      $chatPanel.classList.remove('hidden');
      const localNode = graph?.nodes?.find(n => n.id === id);
      if (localNode) {
        $chatTitle.textContent = localNode.title || id;
      } else {
        $chatTitle.textContent = id;
      }
      $status.textContent = 'Loading topic…';
      fetchNodeDetails(id).then(data => {
        const node = data.node || localNode || { id };
        $chatTitle.textContent = node.title || id;
        $chatMeta.textContent = [node.kind, node.domain ? `domain: ${node.domain}` : null, node.difficulty ? `difficulty: ${node.difficulty}` : null].filter(Boolean).join(' • ');
        renderNodeProgress(id);
        $chatSummary.textContent = node.summary || '';
        const kws = (node.keywords || []).slice(0, 10).map(k => `<span class="tag">${escapeHtml(k)}</span>`).join(' ');
        $chatKeywords.innerHTML = kws;
        renderResources(node);
        const set = getKnown();
        const isKnown = set.has(id);
        $toggleKnown.textContent = isKnown ? 'Known' : 'Mark known';
        $toggleKnown.dataset.state = isKnown ? 'on' : 'off';
        $status.textContent = '';
      }).catch(err => {
        $status.textContent = 'Failed to load topic.';
        setTimeout(() => { $status.textContent = ''; }, 2000);
      });
    }

    // Quiz logic
    const quizCacheKey = 'quizCacheV1';
    const quizResultKey = 'quizResultsV1';
    function getCache(key) {
      try { return JSON.parse(localStorage.getItem(key) || '{}'); } catch { return {}; }
    }
    function setCache(key, obj) {
      localStorage.setItem(key, JSON.stringify(obj));
    }
    function getQuizFromCache(nodeId) {
      const cache = getCache(quizCacheKey);
      return cache[nodeId] || null;
    }
    function saveQuizToCache(nodeId, data) {
      const cache = getCache(quizCacheKey);
      cache[nodeId] = { ...data, savedAt: Date.now() };
      setCache(quizCacheKey, cache);
    }
    function getResults(nodeId) {
      const all = getCache(quizResultKey);
      return all[nodeId] || {};
    }
    function saveResults(nodeId, results) {
      const all = getCache(quizResultKey);
      all[nodeId] = results;
      setCache(quizResultKey, all);
    }

    async function fetchQuiz(nodeId, force = false) {
      if (!force) {
        const cached = getQuizFromCache(nodeId);
        if (cached && Array.isArray(cached.items) && cached.items.length) return cached;
      }
      // Try Netlify function first
      try {
        const res = await fetch('/.netlify/functions/quiz', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ nodeId }) });
        if (res.ok) {
          const data = await res.json();
          saveQuizToCache(nodeId, data);
          return data;
        }
      } catch {}
      // Fallback to local express
      try {
        const res2 = await fetch('/quiz', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ nodeId }) });
        if (res2.ok) {
          const data2 = await res2.json();
          saveQuizToCache(nodeId, data2);
          return data2;
        }
      } catch {}
      // Heuristic offline quiz (MCQ-only)
      const node = graph?.nodes?.find(n => n.id === nodeId) || {};
      const title = node.title || String(nodeId);
      const summary = (node.summary || '').trim() || 'A course concept.';
      const kw = Array.isArray(node.keywords) && node.keywords.length ? node.keywords[0] : '';
      const heuristic = {
        nodeId,
        items: [
          { id: `${nodeId}::h1`, nodeId, type: 'mcq', question: `Which best describes ${title}?`, options: [summary, 'An unrelated topic', 'A historical anecdote', 'A UI component'], answer: summary, explanation: 'Matches the node summary.', sources: [] },
          { id: `${nodeId}::h2`, nodeId, type: 'mcq', question: `Which is a key idea of ${title}?`, options: [kw || 'concept', 'football', 'astronomy', 'cooking'], answer: kw || 'concept', explanation: 'Based on keywords.', sources: [] },
          { id: `${nodeId}::h3`, nodeId, type: 'mcq', question: `Which keyword relates to ${title}?`, options: [kw || 'concept', 'football', 'astronomy', 'cooking'], answer: kw || 'concept', explanation: 'From node keywords.', sources: [] }
        ]
      };
      saveQuizToCache(nodeId, heuristic);
      return heuristic;
    }

    function renderQuiz(nodeId, quiz) {
      $quizBody.innerHTML = '';
      const results = getResults(nodeId);
      const items = (quiz.items || [])
        .map(it => sanitizeMcqItem(it))
        .filter(it => Array.isArray(it.options) && it.options.length === 4 && it.question);
      items.forEach((item, idx) => {
        const wrap = document.createElement('div');
        wrap.style.borderTop = '1px solid #eee';
        wrap.style.paddingTop = '8px';
        const q = document.createElement('div');
        q.style.fontWeight = '600';
        q.textContent = `${idx + 1}. ${item.question}`;
        wrap.appendChild(q);
        const key = item.id;
        const opts = document.createElement('div');
        (item.options || []).forEach((opt, i) => {
          const id = `${key}__${i}`;
          const label = document.createElement('label');
          label.style.display = 'block';
          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.name = key;
          radio.value = opt;
          radio.checked = results[key]?.answer === opt;
          radio.onchange = () => grade(nodeId, item, opt);
          label.appendChild(radio);
          const span = document.createElement('span');
          span.textContent = ' ' + opt;
          label.appendChild(span);
          opts.appendChild(label);
        });
        wrap.appendChild(opts);
        const feedback = document.createElement('div');
        feedback.id = `${key}__fb`;
        feedback.style.fontSize = '13px';
        feedback.style.marginTop = '4px';
        if (results[key]) {
          feedback.textContent = results[key].correct ? `✅ Correct. ${item.explanation || ''}` : `❌ Try again. ${item.explanation || ''}`;
          feedback.style.color = results[key].correct ? '#2e7d32' : '#c62828';
        }
        wrap.appendChild(feedback);
        $quizBody.appendChild(wrap);
      });
    }

    function sanitizeMcqItem(it) {
      const question = String(it?.question || '').slice(0, 500);
      let options = Array.isArray(it?.options) ? it.options.map(s => String(s || '').slice(0, 300)) : [];
      let answer = String(it?.answer || '').slice(0, 300);
      options = (options || []).slice(0, 4);
      while (options.length < 4) options.push('');
      if (answer && !options.includes(answer)) options[0] = answer;
      return { ...it, type: 'mcq', question, options: options.slice(0, 4), answer };
    }

    function grade(nodeId, item, userAnswer) {
      const results = getResults(nodeId);
      const correct = String(userAnswer || '').trim().toLowerCase() === String(item.answer || '').trim().toLowerCase();
      results[item.id] = {
        answer: userAnswer,
        correct,
        attempts: (results[item.id]?.attempts || 0) + 1,
        lastSeenAt: Date.now()
      };
      saveResults(nodeId, results);
      const fb = document.getElementById(`${item.id}__fb`);
      if (fb) {
        fb.textContent = correct ? `✅ Correct. ${item.explanation || ''}` : `❌ Try again. ${item.explanation || ''}`;
        fb.style.color = correct ? '#2e7d32' : '#c62828';
      }
      renderNodeProgress(nodeId);
    }

    async function openQuiz(force = false) {
      if (!currentNodeId) return;
      try {
        $status.textContent = force ? 'Regenerating quiz…' : 'Loading quiz…';
        if (force) {
          // Clear cached quiz and results for this node to ensure regeneration
          const cache = getCache(quizCacheKey);
          delete cache[currentNodeId];
          setCache(quizCacheKey, cache);
          const results = getCache(quizResultKey);
          delete results[currentNodeId];
          setCache(quizResultKey, results);
        }
        const quiz = await fetchQuiz(currentNodeId, force);
        renderQuiz(currentNodeId, quiz);
        $quizPanel.classList.remove('hidden');
        $status.textContent = 'Quiz ready.';
        renderNodeProgress(currentNodeId);
      } catch (e) {
        // As a last resort, show a minimal heuristic quiz
        const offline = await fetchQuiz(currentNodeId, true).catch(() => null);
        if (offline && Array.isArray(offline.items) && offline.items.length) {
          renderQuiz(currentNodeId, offline);
          $quizPanel.classList.remove('hidden');
          $status.textContent = 'Showing offline quiz.';
        } else {
          $quizBody.textContent = 'Failed to load quiz.';
          $quizPanel.classList.remove('hidden');
          $status.textContent = 'Quiz failed.';
        }
      } finally {
        setTimeout(() => { $status.textContent = ''; }, 1500);
      }
    }

    $openQuiz.onclick = () => openQuiz(false);
    $regenQuiz.onclick = () => openQuiz(true);
    $closeQuiz.onclick = () => $quizPanel.classList.add('hidden');

    function fetchNodeDetails(id) {
      return fetch('/.netlify/functions/node', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id }) })
        .then(res => { if (!res.ok) throw new Error('server'); return res.json(); })
        .catch(() => {
          // Fallback compute locally if function not available (e.g., local express)
          const nodesArr = graph?.nodes || [];
          const edgesArr = graph?.edges || [];
          const node = nodesArr.find(n => n.id === id);
          const prerequisites = nodesArr.filter(n => node?.prerequisites?.includes(n.id));
          const dependents = nodesArr.filter(n => n.prerequisites?.includes(id));
          const neighbors = nodesArr.filter(n => dependents.some(d => d.id === n.id) || prerequisites.some(p => p.id === n.id));
          const related = edgesArr.filter(e => e.source === id || e.target === id);
          return { node, prerequisites, dependents, neighbors, edges: related };
        });
    }

    function escapeHtml(s) {
      return String(s || '').replace(/[&<>"']/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[c]));
    }
    function escapeAttr(s) {
      return String(s || '').replace(/[\s"']/g, '_');
    }

    $closeChat.onclick = () => { $chatPanel.classList.add('hidden'); };
    $toggleKnown.onclick = () => {
      if (!currentNodeId) return;
      const set = getKnown();
      if ($toggleKnown.dataset.state === 'on') {
        set.delete(currentNodeId);
      } else {
        set.add(currentNodeId);
      }
      saveKnown(set);
      renderKnown();
      const isNow = set.has(currentNodeId);
      $toggleKnown.textContent = isNow ? 'Known' : 'Mark known';
      $toggleKnown.dataset.state = isNow ? 'on' : 'off';
      renderNodeProgress(currentNodeId);
      updateOverallProgress();
    };

    $chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = ($chatQuestion.value || '').trim();
      if (!text || !currentNodeId) return;
      appendMsg('user', text);
      $chatQuestion.value = '';
      $status.textContent = 'Thinking…';
      try {
        const known = Array.from(getKnown());
        const history = chatHistoryByNode.get(currentNodeId) || [];
        const payload = { focusId: currentNodeId, question: text, knownIds: known, history };
        // Try streaming locally first
        let streamed = false;
        try {
          const res = await fetch('/askNode/stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (!res.ok || !res.body) throw new Error('no stream');
          streamed = true;
          const live = appendStreamedMsg('assistant');
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const chunk = buffer.slice(0, idx);
              buffer = buffer.slice(idx + 2);
              const lines = chunk.split('\n');
              let ev = 'message';
              let data = '';
              for (const ln of lines) {
                if (ln.startsWith('event:')) ev = ln.slice(6).trim();
                else if (ln.startsWith('data:')) data += ln.slice(5).trim();
              }
              if (ev === 'token') {
                live.append(data);
              } else if (ev === 'done') {
                try {
                  const obj = JSON.parse(data);
                  live.finish(obj.answer || live.text());
                  if (Array.isArray(obj.suggestedNext) && obj.suggestedNext.length) {
                    // Render suggested next buttons
                    const div = document.createElement('div');
                    div.style.marginTop = '6px';
                    div.style.fontSize = '13px';
                    div.textContent = 'Suggested next:';
                    obj.suggestedNext.forEach(item => {
                      const b = document.createElement('button');
                      b.className = 'pill';
                      b.style.margin = '4px 4px 0 0';
                      b.textContent = item.id;
                      b.onclick = () => { network.selectNodes([item.id]); network.focus(item.id, { scale: 1.5, animation: { duration: 500, easing: 'easeInOutQuad' } }); openChatForNode(item.id); };
                      div.appendChild(b);
                    });
                    live.root.appendChild(div);
                  }
                } catch {}
              }
            }
          }
          $status.textContent = 'Ready.';
        } catch (_) {}
        if (!streamed) {
          // Fallback to Netlify function (non-streaming)
          let res = await fetch('/.netlify/functions/askNode', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (!res.ok) throw new Error('Server error');
          const data = await res.json();
          const answer = data.answer || '';
          appendMsg('assistant', answer, data);
          $status.textContent = 'Ready.';
        }
      } catch (err) {
        // Local concise fallback: synthesize a compact answer or example from node metadata
        const node = graph?.nodes?.find(n => n.id === currentNodeId) || {};
        const wantsExample = /\b(example|sample|exercise|practice|question\s*example)\b/i.test(text || '');
        let fallback = '';
        if (wantsExample) {
          const title = node.title || String(currentNodeId || 'this topic');
          const kw = Array.isArray(node.keywords) && node.keywords.length ? node.keywords[0] : '';
          // Simple templated example question
          fallback = `Example: For ${title}${kw ? ` (${kw})` : ''}, given a small input, show the expected output.`;
        } else {
          fallback = (node.summary || '').trim() || `This topic is ${node.title || currentNodeId}.`;
        }
        // Enforce < 100 words
        const words = fallback.trim().split(/\s+/);
        if (words.length > 100) fallback = words.slice(0, 100).join(' ');
        appendMsg('assistant', fallback || 'Sorry, I cannot answer that right now.');
        $status.textContent = 'Local fallback used.';
      } finally {
        setTimeout(() => { $status.textContent = ''; }, 1500);
      }
    });

    function appendMsg(role, content, full) {
      const div = document.createElement('div');
      div.className = 'msg ' + role;
      const roleSpan = document.createElement('span');
      roleSpan.className = 'role';
      roleSpan.textContent = role === 'user' ? 'You:' : 'Tutor:';
      const textSpan = document.createElement('span');
      textSpan.textContent = content;
      div.appendChild(roleSpan);
      div.appendChild(textSpan);
      // Citations intentionally omitted to avoid weak pointers
      if (full && Array.isArray(full.suggestedNext) && full.suggestedNext.length) {
        const s = document.createElement('div');
        s.style.marginTop = '6px';
        s.style.fontSize = '13px';
        s.textContent = 'Suggested next:';
        full.suggestedNext.forEach(item => {
          const b = document.createElement('button');
          b.className = 'pill';
          b.style.margin = '4px 4px 0 0';
          b.textContent = item.id;
          b.onclick = () => {
            network.selectNodes([item.id]);
            network.focus(item.id, { scale: 1.5, animation: { duration: 500, easing: 'easeInOutQuad' } });
            openChatForNode(item.id);
          };
          s.appendChild(b);
        });
        div.appendChild(s);
      }
      $chatMessages.appendChild(div);
      $chatMessages.scrollTop = $chatMessages.scrollHeight;
      const hist = chatHistoryByNode.get(currentNodeId) || [];
      hist.push({ role, content });
      chatHistoryByNode.set(currentNodeId, hist.slice(-10));
    }

    function renderResources(node) {
      try {
        const items = Array.isArray(node?.resources) ? node.resources.slice(0, 8) : [];
        const links = items.map(r => {
          const href = localOcwHref(r) || String(r.url || '');
          const label = String(r.label || r.localRef || r.url || 'resource');
          return href ? `<a href="${escapeHtml(href)}" target="_blank" rel="noopener">${escapeHtml(label)}</a>` : '';
        }).filter(Boolean);
        if (links.length) {
          $chatResources.innerHTML = `<div style="font-weight:600; margin-bottom:4px;">Resources</div>` + links.join('');
          $chatResources.classList.remove('hidden');
        } else {
          $chatResources.innerHTML = '';
          $chatResources.classList.add('hidden');
        }
      } catch {
        $chatResources.innerHTML = '';
        $chatResources.classList.add('hidden');
      }
    }

    function localOcwHref(resource) {
      try {
        let localRef = String(resource?.localRef || '').trim();
        // Normalize
        localRef = localRef.replace(/^\/+/, '');
        if (localRef.startsWith('ocw_course/')) localRef = localRef.slice('ocw_course/'.length);
        if (localRef) return `/ocw/${localRef}`;

        const url = String(resource?.url || '').trim();
        if (!url) return '';
        try {
          const u = new URL(url);
          if (u.hostname.includes('ocw.mit.edu')) {
            // Try to map to local snapshot by keeping from /pages/... onward
            const m = u.pathname.match(/\/(pages\/.*)$/);
            if (m && m[1]) return `/ocw/${m[1]}`;
          }
        } catch {}
        return '';
      } catch { return ''; }
    }

    function renderNodeProgress(nodeId) {
      try {
        const el = document.getElementById('chatProgress');
        if (!el) return;
        const known = getKnown();
        if (known.has(nodeId)) {
          el.textContent = 'Progress: Known';
          return;
        }
        const results = getResults(nodeId);
        let correct = 0;
        let total = 0;
        const cached = getQuizFromCache(nodeId);
        if (cached && Array.isArray(cached.items)) {
          total = cached.items.length;
          correct = cached.items.reduce((acc, it) => acc + (results[it.id]?.correct ? 1 : 0), 0);
        } else {
          const keys = Object.keys(results || {});
          total = keys.length;
          correct = keys.reduce((acc, k) => acc + (results[k]?.correct ? 1 : 0), 0);
        }
        if (total > 0) {
          el.textContent = `Quiz progress: ${correct}/${total} correct`;
        } else {
          el.textContent = 'Quiz progress: —';
        }
      } catch {}
    }

    function appendStreamedMsg(role) {
      const div = document.createElement('div');
      div.className = 'msg ' + role;
      const roleSpan = document.createElement('span');
      roleSpan.className = 'role';
      roleSpan.textContent = role === 'user' ? 'You:' : 'Tutor:';
      const textSpan = document.createElement('span');
      textSpan.textContent = '';
      div.appendChild(roleSpan);
      div.appendChild(textSpan);
      $chatMessages.appendChild(div);
      $chatMessages.scrollTop = $chatMessages.scrollHeight;
      const hist = chatHistoryByNode.get(currentNodeId) || [];
      hist.push({ role, content: '' });
      chatHistoryByNode.set(currentNodeId, hist.slice(-10));
      return {
        root: div,
        append(chunk) {
          textSpan.textContent += chunk;
          $chatMessages.scrollTop = $chatMessages.scrollHeight;
        },
        finish(finalText) {
          textSpan.textContent = finalText || textSpan.textContent;
        },
        text() { return textSpan.textContent; }
      };
    }
  </script>
</body>
</html>
