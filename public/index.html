<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Graph Learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; font: 16px system-ui, -apple-system, Segoe UI, Roboto; }
    #toolbar { padding: 8px 12px; border-bottom: 1px solid #eee; display:flex; gap:8px; align-items:center; }
    #cy { width: 100vw; height: calc(100vh - 56px); }
    .pill { padding:4px 8px; border:1px solid #ddd; border-radius:999px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="q" placeholder="Search conceptâ€¦" class="pill"/>
    <button id="focus" class="pill">Focus</button>
    <button id="reset" class="pill">Reset</button>
    <button id="suggest" class="pill">What next?</button>
    <span id="status"></span>
  </div>
  <div id="cy"></div>

  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script>
    const container = document.getElementById('cy');
    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);

    function edgeColor(type) {
      if (type === 'prereq') return '#2c3e50';
      if (type === 'refines') return '#8e44ad';
      if (type === 'applies-to') return '#27ae60';
      return '#bbb';
    }

    const options = {
      interaction: { hover: true, multiselect: true, selectConnectedEdges: true },
      physics: {
        enabled: true,
        solver: 'barnesHut',
        stabilization: { iterations: 150, updateInterval: 25 }
      },
      nodes: { shape: 'dot', size: 14, font: { size: 12 }, borderWidth: 1 },
      edges: {
        width: 1,
        arrows: { to: { enabled: true, scaleFactor: 0.6 } },
        smooth: { type: 'dynamic' },
        color: { color: '#bbb', highlight: '#f39c12' }
      },
      groups: {
        concept: { color: { background: '#3498db', border: '#2980b9' } },
        skill: { color: { background: '#1abc9c', border: '#16a085' } },
        example: { color: { background: '#95a5a6', border: '#7f8c8d' } },
        theorem: { color: { background: '#e67e22', border: '#d35400' } }
      }
    };

    const network = new vis.Network(container, { nodes, edges }, options);

    let graph;
    fetch('/graph').then(r => r.json()).then(g => {
      graph = g;
      nodes.add(g.nodes.map(n => ({ id: n.id, label: n.title, title: n.summary || '', group: n.kind })));
      edges.add(g.edges.map(e => ({
        id: `${e.source}->${e.target}:${e.type}`,
        from: e.source,
        to: e.target,
        arrows: 'to',
        dashes: e.type === 'refines' ? [5, 5] : (e.type === 'applies-to' ? [10, 5] : false),
        color: { color: edgeColor(e.type) }
      })));
      network.fit({ animation: { duration: 500, easing: 'easeInOutQuad' } });

      network.on('click', (params) => {
        if (params.nodes && params.nodes.length) {
          const id = params.nodes[0];
          const n = nodes.get(id);
          alert(`${n.label}\n\n${n.title || ''}`);
        }
      });
    });

    const $q = document.getElementById('q');
    document.getElementById('focus').onclick = () => {
      const term = $q.value.trim().toLowerCase();
      if (!term) return;
      const matches = nodes.getIds({ filter: it => (it.label || '').toLowerCase().includes(term) || String(it.id).toLowerCase().includes(term) });
      if (matches.length) {
        const id = matches[0];
        const neighborhood = new Set([id, ...network.getConnectedNodes(id)]);
        const allNodes = nodes.getIds();
        const allEdges = edges.getIds();
        nodes.update(allNodes.map(nid => ({ id: nid, hidden: !neighborhood.has(nid) })));
        edges.update(allEdges.map(eid => {
          const e = edges.get(eid);
          const visible = neighborhood.has(e.from) && neighborhood.has(e.to);
          return { id: eid, hidden: !visible };
        }));
        network.fit({ nodes: Array.from(neighborhood), animation: { duration: 500, easing: 'easeInOutQuad' } });
      }
    };

    document.getElementById('reset').onclick = () => {
      nodes.update(nodes.get().map(n => ({ id: n.id, hidden: false })));
      edges.update(edges.get().map(e => ({ id: e.id, hidden: false })));
      network.fit({ animation: { duration: 500, easing: 'easeInOutQuad' } });
    };

    document.getElementById('suggest').onclick = async () => {
      const selected = network.getSelectedNodes();
      const res = await fetch('/ask', { method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question: 'What should I learn next?', knownIds: selected }) });
      const { answer } = await res.json();
      alert(answer);
    };
  </script>
</body>
</html>
